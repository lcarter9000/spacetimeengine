import sympy as sp

def metric_polar():
    r, theta = sp.symbols('r theta')
    g = sp.Matrix([[1, 0],
                   [0, r**2]])
    return (r, theta), g, g.inv()

def christoffel_from_metric(g, coords):
    try:
        from sympy.tensor.riemann import metric_to_Christoffel_2nd
        return metric_to_Christoffel_2nd(g, list(coords))  # shape: [k][i,j]
    except Exception:
        # Fallback manual computation
        n = len(coords)
        g_inv = g.inv()
        Gamma = [[[0 for _ in range(n)] for _ in range(n)] for _ in range(n)]
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    term = 0
                    for l in range(n):
                        term += g_inv[k, l] * (
                            sp.diff(g[l, j], coords[i]) +
                            sp.diff(g[l, i], coords[j]) -
                            sp.diff(g[i, j], coords[l])
                        )
                    Gamma[k][i][j] = sp.simplify(sp.Rational(1, 2) * term)
        return Gamma  # nested Python lists

def covariant_derivative_covector(v, Gamma, coords):
    # ∇_j v_i = ∂_j v_i - Γ^k_{ij} v_k
    n = len(coords)
    nabla = [[None]*n for _ in range(n)]
    sympy_style = isinstance(Gamma[0], list)  # manual vs sympy tensor form
    for i in range(n):
        for j in range(n):
            partial = sp.diff(v[i], coords[j])
            if sympy_style:
                correction = sum(Gamma[k][i][j] * v[k] for k in range(n))
            else:
                correction = sum(Gamma[k][i, j] * v[k] for k in range(n))
            nabla[i][j] = sp.simplify(partial - correction)
    return nabla

def main(output_path="covariant_derivatives_latex.txt"):
    (r, theta), g, _ = metric_polar()
    coords = [r, theta]
    Gamma = christoffel_from_metric(g, coords)
    # Covariant vector components v_r, v_theta
    v = sp.Matrix([4*r, 20*theta])
    nabla_v = covariant_derivative_covector(v, Gamma, coords)

    lines = []
    for i, ci in enumerate(coords):
        for j, cj in enumerate(coords):
            expr = nabla_v[i][j]
            lines.append(f"\\nabla_{{{cj}}} v_{{{ci}}} = {sp.latex(expr)}")

    with open(output_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines))

    print("Computed covariant derivatives and saved LaTeX to", output_path)

if __name__ == "__main__":
    main()
