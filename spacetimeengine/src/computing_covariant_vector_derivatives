# Creating symbolic covariant derivative computation in polar coordinates using SymPy
import sympy as sp
from sympy.tensor.tensor import (
    TensorIndexType,
    tensor_indices,
    TensorHead,
    tensorhead,
    riemann_cyclic_replace,
)
from sympy.tensor.riemann import metric_to_Christoffel_2nd

# Step 1: Define polar coordinates
r, theta = sp.symbols("r theta")
coords = [r, theta]

# Step 2: Construct the metric tensor g_ij for polar coordinates
# In polar coordinates: ds² = dr² + r² dθ²
g = sp.Matrix([[1, 0], [0, r**2]])
g_inv = g.inv()

# Step 3: Compute Christoffel symbols of the second kind
Gamma = metric_to_Christoffel_2nd(g, coords)

# Step 4: Define covariant vector field v_i with components v_r = 4r, v_θ = 20θ
v = sp.Matrix([4 * r, 20 * theta])

# Step 5: Compute covariant derivatives ∇_j v_i
# ∇_j v_i = ∂v_i/∂x^j - Γ^k_ij v_k
n = len(coords)
nabla_v = [[0] * n for _ in range(n)]

for i in range(n):
    for j in range(n):
        partial = sp.diff(v[i], coords[j])
        correction = sum(Gamma[k][i, j] * v[k] for k in range(n))
        nabla_v[i][j] = sp.simplify(partial - correction)

# Step 6: Display results
latex_output = []
for i in range(n):
    for j in range(n):
        expr = sp.simplify(nabla_v[i][j])
        latex_output.append(f"\\nabla_{{{coords[j]}}} v_{{{coords[i]}}} = {sp.latex(expr)}")

# Save LaTeX output to a text file
output_path = "/mnt/data/covariant_derivatives_latex.txt"
with open(output_path, "w") as f:
    for line in latex_output:
        f.write(line + "\n")

print(
    "Computed covariant derivatives ∇_j v_i in polar coordinates and saved LaTeX expressions to covariant_derivatives_latex.txt"
)
